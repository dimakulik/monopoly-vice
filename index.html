<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <title>monopoly_tg</title>

  <style>
    *{box-sizing:border-box}
    html,body{
      margin:0;padding:0;width:100%;height:100%;
      background:#2b353d;overflow:hidden;
      font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Arial;
    }

    :root{
      --vh:1vh;
      --board:300px;

      --gap:0px;     /* без разрыва между ценой и полем */
      --ph:16px;     /* высота цены сверху/снизу */
      --pw:22px;     /* ширина цены слева/справа */
      --pr:0px;      /* квадратные */
      --grid:2px;
      --grid-color: rgba(0,0,0,.22);
    }

    #app{
      width:100%;
      height:calc(var(--vh)*100);
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .outer{
      position:relative;
      width:calc(var(--board) + (var(--pw) + var(--gap))*2);
      height:calc(var(--board) + (var(--ph) + var(--gap))*2);
    }

    .board{
      position:absolute;
      left:50%;top:50%;
      transform:translate(-50%,-50%);
      width:var(--board);
      height:var(--board);
      background:rgba(10,14,18,.28);
      overflow:hidden;
      z-index:1; /* поле ниже ценников */

      outline: var(--grid) solid var(--grid-color);
      box-shadow:
        0 18px 50px rgba(0,0,0,.35),
        inset 0 0 0 var(--grid) var(--grid-color);
    }

    .cell{
      position:absolute;
      background:#fff;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:2; /* клетки ниже ценников */
      box-shadow: inset 0 0 0 var(--grid) var(--grid-color);
    }
    .cell img{
      width:100%;
      height:100%;
      object-fit:contain;
      padding:6px;
      display:block;
    }

    /* ценники поверх всего */
    .price{
      position:absolute;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#fff;
      font-weight:900;
      border-radius:var(--pr);
      pointer-events:none;
      overflow:hidden;
      font-variant-numeric: tabular-nums;
      box-shadow:none;
      z-index:10; /* <- фикс: чтобы снизу НЕ исчезали */
    }
    .price span{
      display:block;
      white-space:nowrap;
      font-size:11px;
      transform-origin:center;
      line-height:1;
    }
    .price.tb{ height:var(--ph); padding:0 3px; }
    .price.lr{ width:var(--pw); padding:0; }
    .price.left  span{ transform:rotate(-90deg); }
    .price.right span{ transform:rotate( 90deg); }

    .chat{
      position:absolute;
      left:50%;
      bottom:14%;
      transform:translateX(-50%);
      width:72%;
      background:rgba(35,43,50,.85);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:8px;
      display:flex;
      gap:8px;
      backdrop-filter: blur(8px);
      z-index:5;
    }
    .chat input{
      flex:1;height:36px;border-radius:999px;border:none;
      padding:0 14px;background:rgba(255,255,255,.12);
      color:#fff;outline:none;min-width:0;
    }
    .chat button{
      width:42px;border:none;border-radius:999px;
      background:rgba(255,255,255,.2);
      color:#fff;font-weight:900;
    }
  </style>
</head>

<body>
<div id="app">
  <div class="outer" id="outer">
    <div class="board" id="board">
      <div class="chat">
        <input placeholder="Введите сообщение" />
        <button>➤</button>
      </div>
    </div>
  </div>
</div>

<script>
  const tg = window.Telegram?.WebApp;
  if (tg) { try { tg.expand(); } catch(e){} }

  function setVH(){
    const h = tg?.viewportStableHeight || window.innerHeight;
    document.documentElement.style.setProperty('--vh', (h*0.01)+'px');
  }
  setVH();
  window.addEventListener('resize', setVH);

  const outer = document.getElementById('outer');
  const board = document.getElementById('board');

  const prices = ["200k","400k","600k","800k","1,000k","1,200k","1,500k","2,000k","2,200k","2,400k","2,600k","3,000k"];
  const colors = ["#f97316","#ec4899","#22c55e","#3b82f6","#a855f7","#ef4444"];
  const CORNERS = new Set([0,10,20,30]);

  const CELL_COUNT = 40;
  const cells = [];
  const tags  = [];
  const cellBox = Array.from({length:CELL_COUNT}, ()=>({x:0,y:0,w:0,h:0}));

  const logoSVG = 'data:image/svg+xml;utf8,' + encodeURIComponent(
    `<svg xmlns="http://www.w3.org/2000/svg" width="240" height="240">
      <rect width="240" height="240" fill="#fff"/>
      <text x="50%" y="58%" font-size="36" text-anchor="middle" fill="#000">GO</text>
    </svg>`
  );

  for(let i=0;i<CELL_COUNT;i++){
    const c = document.createElement('div');
    c.className = 'cell';
    const img = document.createElement('img');
    img.src = logoSVG;
    c.appendChild(img);
    board.appendChild(c);
    cells.push(c);

    const p = document.createElement('div');
    p.className = 'price';
    p.style.background = colors[i % colors.length];
    p.innerHTML = `<span>${prices[i % prices.length]}</span>`;
    if (CORNERS.has(i)) p.style.display = 'none';
    outer.appendChild(p);
    tags.push(p);
  }

  // автоподжим текста
  function fit(tag){
    if (tag.style.display === 'none') return;
    const span = tag.querySelector('span');
    if (!span) return;

    const isTB = tag.classList.contains('tb');
    const limit = isTB ? tag.clientWidth : tag.clientHeight;

    span.style.transform = '';
    const needed = span.scrollWidth;
    const scale = Math.min(1, (limit - 2) / Math.max(1, needed));

    if (tag.classList.contains('lr')) {
      const rot = tag.classList.contains('right') ? 'rotate(90deg)' : 'rotate(-90deg)';
      span.style.transform = `${rot} scale(${scale})`;
    } else {
      span.style.transform = `scale(${scale})`;
    }
  }

  function placeCell(idx, x,y,w,h){
    cellBox[idx] = {x,y,w,h};
    Object.assign(cells[idx].style, {left:x+'px', top:y+'px', width:w+'px', height:h+'px'});
  }

  function placePrice(idx, side){
    const tag = tags[idx];
    if (tag.style.display === 'none') return;

    const css = getComputedStyle(document.documentElement);
    const gap = parseInt(css.getPropertyValue('--gap')) || 0;
    const ph  = parseInt(css.getPropertyValue('--ph'))  || 16;
    const pw  = parseInt(css.getPropertyValue('--pw'))  || 22;

    const b = cellBox[idx];

    const br = board.getBoundingClientRect();
    const or = outer.getBoundingClientRect();
    const ox = br.left - or.left;
    const oy = br.top  - or.top;

    const boardW = Math.round(br.width);
    const boardH = Math.round(br.height);

    let x=0,y=0,w=0,h=0, cls='';

    if (side === 'top'){
      cls = 'tb';
      x = b.x;
      y = -ph - gap;
      w = b.w;
      h = ph;
    } else if (side === 'bottom'){
      cls = 'tb';
      x = b.x;
      y = boardH + gap;
      w = b.w;
      h = ph;
    } else if (side === 'left'){
      cls = 'lr left';
      x = -pw - gap;
      y = b.y;
      w = pw;
      h = b.h;
    } else if (side === 'right'){
      cls = 'lr right';
      x = boardW + gap;
      y = b.y;
      w = pw;
      h = b.h;
    }

    tag.className = 'price ' + cls;
    Object.assign(tag.style, {
      left: Math.round(ox + x) + 'px',
      top:  Math.round(oy + y) + 'px',
      width: Math.round(w) + 'px',
      height: Math.round(h) + 'px'
    });

    // IMPORTANT: фитим после того как браузер применил размеры
    requestAnimationFrame(()=>fit(tag));
  }

  // распределяем лишние пиксели по 9 клеткам, чтобы край всегда попадал в угол
  function rowSegments(total){
    const base = Math.floor(total / 9);
    const rem  = total - base*9; // 0..8
    const widths = Array.from({length:9}, (_,i)=> base + (i < rem ? 1 : 0));
    const offs = [0];
    for(let i=0;i<9;i++) offs.push(offs[i] + widths[i]);
    return {widths, offs}; // offs длиной 10
  }

  function layout(){
    const size = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--board')) || 300;

    const corner = Math.round(size * 0.135);
    const inner = size - corner*2;

    const seg = rowSegments(inner); // 9 сегментов
    const W = seg.widths;
    const O = seg.offs; // 0..9

    // corners
    placeCell(0, 0, 0, corner, corner);

    // top 1..9 (идеально стык в угол)
    for(let i=1;i<=9;i++){
      const x = corner + O[i-1];
      placeCell(i, x, 0, W[i-1], corner);
    }
    placeCell(10, size-corner, 0, corner, corner);

    // right 11..19
    for(let i=11;i<=19;i++){
      const y = corner + O[i-11];
      placeCell(i, size-corner, y, corner, W[i-11]);
    }
    placeCell(20, size-corner, size-corner, corner, corner);

    // bottom 21..29
    for(let i=21;i<=29;i++){
      const k = i-21; // 0..8
      const x = corner + O[9-(k+1)];           // старт справа налево
      const w = W[9-(k+1)];
      placeCell(i, x, size-corner, w, corner);
    }
    placeCell(30, 0, size-corner, corner, corner);

    // left 31..39
    for(let i=31;i<=39;i++){
      const k = i-31; // 0..8
      const y = corner + O[9-(k+1)];
      const h = W[9-(k+1)];
      placeCell(i, 0, y, corner, h);
    }

    // prices (без углов)
    for(let i=1;i<=9;i++)  placePrice(i,'top');
    for(let i=11;i<=19;i++) placePrice(i,'right');
    for(let i=21;i<=29;i++) placePrice(i,'bottom');
    for(let i=31;i<=39;i++) placePrice(i,'left');

    [0,10,20,30].forEach(i => tags[i].style.display = 'none');
  }

  function resize(){
    const H = tg?.viewportStableHeight || innerHeight;
    const W = innerWidth;

    const gap=0, ph=16, pw=22;
    const maxOuterW = W - 20;
    const maxOuterH = H - 160;

    const boardMaxByW = maxOuterW - 2*(pw+gap);
    const boardMaxByH = maxOuterH - 2*(ph+gap);

    const size = Math.max(240, Math.floor(Math.min(boardMaxByW, boardMaxByH)));
    document.documentElement.style.setProperty('--board', size + 'px');

    requestAnimationFrame(layout);
  }

  resize();
  window.addEventListener('resize', resize);
</script>
</body>
</html>
